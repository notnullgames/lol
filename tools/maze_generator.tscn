[gd_scene load_steps=3 format=2]

[ext_resource path="res://tiles/maze.tres" type="TileSet" id=1]

[sub_resource type="GDScript" id=1]
script/source = "extends Node2D

export var  MAZE_SIZE = Vector2(31,17)
export var  MAZE_POS = Vector2(1, 1)
export var WALL_ID = 0
export var PATH_ID = 1
export var LIMIT_ID = 2
const DIRECTIONS = [
	Vector2.UP * 2,
	Vector2.DOWN * 2,
	Vector2.RIGHT * 2,
	Vector2.LEFT * 2,
]
var current_cell = Vector2.ONE
var visited_cells = [current_cell]
var stack = []
var cells = []

func _ready():
	current_cell += MAZE_POS - Vector2.ONE
	generate_maze()

func _input(event):
	if event.is_action_pressed(\"ui_accept\"):
		generate_maze()
	if event.is_action_pressed(\"ui_save\"):
		save_maze()
	if event.is_action_pressed(\"ui_up\"):
		MAZE_SIZE = MAZE_SIZE + Vector2(0, 1)
		current_cell = Vector2.ONE
		generate_maze()

func save_maze():
	var d = OS.get_datetime()
	var filename = \"res://maps/maze-%d-%d-%d_%d-%d-%d.tscn\" % [d.month, d.day, d.year, d.hour, d.minute, d.second]
	var packed_scene = PackedScene.new()
	packed_scene.pack($maze)
	ResourceSaver.save(filename, packed_scene)
	print(\"saved to %s\" % filename)

### MAZE GENERATION ###

func generate_maze():
	#Clear the maze
	visited_cells = [current_cell]
	stack.clear()
	# Create walls
	for x in MAZE_SIZE.x:
		for y in MAZE_SIZE.y:
			$maze.set_cell(x+MAZE_POS.x, y+MAZE_POS.y, WALL_ID)
	# Create limits
	for x in MAZE_SIZE.x+2:
		$maze.set_cell(x+MAZE_POS.x-1, MAZE_POS.y-1, LIMIT_ID)
		$maze.set_cell(x+MAZE_POS.x-1, MAZE_POS.y-2, LIMIT_ID)
	for x in MAZE_SIZE.x+2:
		$maze.set_cell(x+MAZE_POS.x-1, MAZE_SIZE.y + MAZE_POS.y, LIMIT_ID)
		$maze.set_cell(x+MAZE_POS.x-1, MAZE_SIZE.y + MAZE_POS.y+1, LIMIT_ID)
	for y in MAZE_SIZE.y:
		$maze.set_cell(MAZE_POS.x-1, MAZE_POS.y + y , LIMIT_ID)
		$maze.set_cell(MAZE_POS.x-2, MAZE_POS.y + y , LIMIT_ID)
	for y in MAZE_SIZE.y:
		$maze.set_cell(MAZE_SIZE.x + MAZE_POS.x, MAZE_POS.y + y , LIMIT_ID)
		$maze.set_cell(MAZE_SIZE.x + MAZE_POS.x+1, MAZE_POS.y + y , LIMIT_ID)
	#create cells
	for x in (MAZE_SIZE.x+1)/2:
		for y in (MAZE_SIZE.y + 1)/2:
			$maze.set_cell(MAZE_POS.x + 2 * x , MAZE_POS.y + 2 * y, PATH_ID)
	#get cells
	cells = $maze.get_used_cells_by_id(PATH_ID)
	#generate maze
	while visited_cells.size() < cells.size():
		var neighbours = neighbours_have_not_been_visited(current_cell)
		if neighbours.size() > 0:
			var random_neighbour = neighbours[randi()%neighbours.size()]
			stack.push_front(current_cell)
			var wall = (random_neighbour - current_cell)/2 + current_cell
			$maze.set_cell(int(wall.x), int(wall.y), 1)
			current_cell = random_neighbour
			visited_cells.append(current_cell)
		elif stack.size() > 0:
			current_cell = stack[0]
			stack.pop_front()

func neighbours_have_not_been_visited(cell):
	var neighbours = []
	for dir in DIRECTIONS:
		if not visited_cells.has(cell + dir) and $maze.get_cell(int(cell.x + dir.x), int(cell.y + dir.y)) != LIMIT_ID:
			neighbours.append(cell + dir)
	return neighbours
"

[node name="Node2D" type="Node2D"]
script = SubResource( 1 )
WALL_ID = 3
PATH_ID = 4
LIMIT_ID = 5

[node name="maze" type="TileMap" parent="."]
position = Vector2( -4, -4 )
tile_set = ExtResource( 1 )
cell_size = Vector2( 32, 32 )
cell_custom_transform = Transform2D( 32, 0, 0, 32, 0, 0 )
format = 1
